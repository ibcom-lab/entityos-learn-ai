/*
	AI factory; GPT / LLM / CLAUDE 3
	See README.md

    Example 1: Conversation Assistant
    Check conversations that part of and check for messages that have 
    [@genai:{user message}]
    Post a comment.

    In event mind to a particular conversation.guid for now.

	References:
	- https://docs.anthropic.com/claude/reference/messages_post
	- https://docs.anthropic.com/claude/docs/models-overview

	
	curl https://api.anthropic.com/v1/messages \
		--header "x-api-key: $ANTHROPIC_API_KEY" \
		--header "anthropic-version: 2023-06-01" \
		--header "content-type: application/json" \
		--data \
	'{
		"model": "claude-3-opus-20240229",
		"max_tokens": 1024,
		"messages": [
			{"role": "user", "content": "Hello, world"}
		]
	}'
*/

var entityos = require('entityos')
var _ = require('lodash')
var moment = require('moment');

module.exports = 
{
	VERSION: '1.0.0',

	init: function (param)
	{
		entityos.add(
		{
			name: 'ai-gen-util-get-settings',
			code: function (param)
			{
				let data = entityos.get({scope: '_data'});
				const settings = entityos.get({scope: '_settings'});

				let model;
				let services = settings.ai.services;

				if (data.service != undefined)
				{
					services = _.filter(services, function (service)
					{
						return (service.name == data.service)
					});
				}

				if (data.model == undefined && data.service != undefined)
				{
					_.each(services, function(service)
					{
						if (model == undefined)
						{
							model = _.find(service.models, function (model)
							{
								return (model.default)
							});
						}
					});
				}
				else if (data.model != undefined && data.service == undefined)
				{
					_.each(services, function(service)
					{
						if (model == undefined)
						{
							model = _.find(service.models, function (model)
							{
								return (model.name == data.model)
							});
						}
					})
				}
				else if (data.model == undefined && data.service == undefined)
				{
					services = _.filter(services, function (service)
					{
						return (service.default)
					})

					_.each(services, function(service)
					{
						if (model == undefined)
						{
							model = _.find(service.models, function (model)
							{
								return (model.default)
							});
						}
					})
				}

				let service;

				if (model != undefined)
				{
					_.each(services, function(_service)
					{
						if (service == undefined)
						{
							model = _.find(_service.models, function (_model)
							{
								return (_model.name == model.name)
							});

							if (model != undefined)
							{
								service = _service;
							}
						}
					})
				}

				if (service != undefined)
				{
					if (service.namespaces != undefined)
					{
						_.each(service.namespaces, function (namespace)
						{
							var aifactory = require('aifactory/aifactory.' + namespace + '.js');

							if (_.has(aifactory, 'init'))
							{
								aifactory.init();
							}
						})
					}
				}

				return {model: model, service: service};
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-chat',
			code: function (param)
			{          
                const settings = entityos.get({scope: '_settings'});

				let aiSettings = _.get(param, 'settings');

				if (aiSettings == undefined)
				{
					//use ai-gen-util-get-model with modelName
				}
				else
				{			
					let messages = _.get(param, 'messages', {});

					if (_.get(messages, 'system') == undefined)
					{
						messages.system = _.get(settings, 'ai.defaults.messages.system');
					}

					const host = _.get(aiSettings, 'service.host'); 

					if (host == undefined)
					{
						entityos.invoke('util-end', {error: 'No host settings.'});
					}
					else
					{
						if (messages.user == undefined)
						{
							entityos.invoke('util-end', {error: 'No user message (prompt text)'});
						}
						else
						{
							let hostName = host.name;
							let hostPath = host.path;

							let keyPath = _.get(aiSettings, 'service.keypath');
							
							let apiKey = _.get(settings, keyPath);

							if (hostName == undefined || hostPath == undefined || apiKey == undefined)
							{
								entityos.invoke('util-end', {error: 'url, urlpath, or apikey is missing.'});
							}
							else
							{
								// Need to make headers, asSettings/Service driven
								let headers =
								{
									'x-api-key': apiKey,
									'Content-Type': 'application/json',
									Accept: 'application/json'
								}

								if (_.get(aiSettings, 'service.headers') != undefined)
								{
									headers = _.assign(headers, aiSettings.service.headers)
								}

								const maxTokensDefault = _.get(settings, 'ai.defaults.maxtokens', 1000);
								const temperatureDefault = _.get(settings, 'ai.defaults.temperature', 0.7);

								const maxTokensDefaultService = _.get(aiSettings, 'service.defaults.maxtokens', maxTokensDefault);
								const tempatureDefaultService = _.get(aiSettings, 'service.defaults.temperature', temperatureDefault);
									
								const maxTokens = _.get(param, 'maxTokens', maxTokensDefaultService);
								const temperature = _.get(param, 'temperature', tempatureDefaultService);

								var sendOptions = 
								{
									hostname: hostName,
									path: hostPath,
									headers: headers,
									action: 'POST',
									callback: 'ai-gen-util-chat-response',
									onComplete: param.onComplete,
									data:
									{
										model: aiSettings.model.name
									}
								}

								sendOptions.data.system =  param.messages.system;
								sendOptions.data.max_tokens = maxTokens;
								sendOptions.datatemperature = temperature;

								sendOptions.data.messages =
								[
									{ role: 'user', content: messages.user },
									{ role: 'system', content: messages.system }
								]

								entityos._util.send(sendOptions, 'ai-gen-util-chat-response');
							}
						}
					}
				}
			}
		});

		entityos.add(
		{
			name: 'ai-gen-util-chat-response',
			code: function (param, response)
			{	
				console.log(response.data);
				const completion = response.data;
				
				if (completion.type == 'error')
				{
					param.error = response.error;
					entityos.invoke('util-end', {error: completion.error});
				}
				else
				{
					_.set(param, 'messages.response', completion.content[0].text);

					if (_.get(param, 'onComplete') != undefined)
					{
						entityos._util.onComplete(param)
					}
					else
					{
						entityos.invoke('util-end', param);
					}
				}
			}
		});
	}
}